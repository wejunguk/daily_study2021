# daily_study2021

# 2021_07_08
  - eomcs-java : 모든 프로젝트가 다 있음
  - ../lang : 자바 언어에 대한 것들이 담겨있음
  - ../basic : 자바 calss사용법 설명
  - ../oop:객체지향 문법 설명 
   -../io,net : 그 외 해당되는 것 들
  - java-basic(단일 프로젝트 구조) : 실습 프로젝트
  - ../lang/ex02 : 주석
  - ex03:리터널
  - ex04:변수일부 0510~0560:배열
  - ex06 : 310,410 while,if 반복문 (리터널,변수,if,while반복문)

  -

# 2021_07_12 (이클립스 디버거 사용)
  - 토글 브레이크포인트 -> 원하는 소스코드 라인 왼쪽을 더블클릭하면 브레이크포인트를 설정할수 있음
    -> 디버그 모드 실행 -> 스텝오버 버튼으로 실행 순서를 하나씩 확인할 수 있음
    * resume : 다음 브레이크 포인트를 만날때까지 진행
    * step over(f6) : 다음 라인으로 이동
    * step into(f5) : 그 메서드 안으로 들어가고 싶다

# 2021_07_14 (메서드 / eomcs-java/com.eomcs.lang_ex07)
  app-03-a -> app-03-b 수정
  - 프로젝트 03-b 복습 후 메서드 개념 진행
  - 자바 파일을 실행하면 JVM이 램으로부터 128MB의 메모리를 할당받고 세 공간으로 나누어 사용한다.
    1) Method Area
      이 공간은 .class의 모든 소스코드를 두는 곳
    2) JVM Stack
      메소드를 호출 할때 각 매소드별로 프레임을 임시 생성
      프레임안에는 그 메소드의 로컬변수를 둔다. 메소드가 끝나면 프레임은 사라진다.
      (로컬변수안엔 파라미터(매개변수) 포함)
    3) Heap
      new 명령으로 생성하는 변수를 둔다
      예)Scanner scan = new Scanner(System.in) 같은 경유 scan이라는 인스턴스 변수를 둔다.

  - 메인이 돌면서 그안에 swap을 호출하는것이 있으니 메인호출하고 사라지지 않은 상태에서 swap 호출하고 swap사라지고
    main 사라지고 JVM Stack에서 프레임으로, 메인메소드가 끝나면 실행이 끝났다 = jvm이 종료됐다

# 2021_07_19
  - 05-b : 코드는 그대로 두고 값만 따로 관리하면 되지 않을까?

# 2021_07_21
  - new 변수가 없으면(=인스턴스 변수가 없으면) Heap에 아무것도 안 만들어지나?
    -> 아니다. 인스턴스의 기본정보(=부가정보->클래스 이름이나 주소값 등 ..)를 저장할 변수가 추가된다.
  
  - Methed Area
    - 클래스 코드
    - static 변수
    - 상수
  - JVM steck
    - local 변수
  - Heap
    - 인스턴스 변수
    - 메소드코드X (절대절대 여기 없음!!!)

  - new BoardHandler() - > BoardHandler가 작업할 동안 사용할 변수 준비!(=BoardHanler의 인스턴스 생성)
  - new Board() -> Board에 사용할 변수 준비
    * 메서드가 있고 메서드가 사용하려면 인스턴스로 넘겨라
  - equalsIngnoreCase -> 대소문자구별없이 진행함

# 2021_07_23 (보충필요)
  - this.boards[--this.size] = null; 
    -> 값을 null로 초기화해주는 이유 -> 값을 삭제시 앞으로 하나씩 밀려오는데........
  - int boardIndex = indexOf(no); 
    -> int 데이터 타입인 boardIndex 변수에 indexOf(no) 만든 걸 넣겠다.

# 2021_07_26 (의존객체 / 06-b->07-a)
  - App파일이 BoardHandler를 사용할 때 (non-static 메서드)
    - new로 인스턴스를 생성
    - 인스턴스 주소값을 저장하는 boardHandler를 불러서 메서드 호출
  - BoardHandler파일이 Prompt를 사용할 때 (static 메서드)
    - 클래스명으로 바로 가지고 와서 메서드 호출
    => 결론 : 인스턴스를 가지고 메서드를 호출하든, 클래스를 가지고 메서드를 호출하든, 둘 다 의존객체이다.

## 2021_07_29 (#오버로딩 #상속 #오버라이딩)
  - 클래스
    1) 새 데이터타입 정의(데이터)
	  2) 기능 묶음(업무) *기능 function=method   ex) 프로젝트핸들러
  - Specialization
    수퍼클래스를 상속받아 좀 더 특별한 역활을 하고 서브클래스를 만드는 것!
  - printSedan(Sedan car) {
    }
    -> 파라미터 : Sedan -> 파라미터에 Sdan 선언, Sdan 및 Sdan의 자식 클래스의 인스터스 값도 넘어간다!(다형적 변수)

## 2021_08_05
  - 캡슐화  = 복잡한 코드를 분리하여 메서드에 감춘다.
  - 역활을 쪼갠다 = High Cohesion
  - 교체가 쉽다
  - 공통적인 부분을 추출 -> 슈퍼클래스, 슈퍼클래스 .....최상위 클래스(object)로 정의 


## 2021_08_09
  - final 앞에 붙어있음 오버라이딩(재정의) 못함
    추상메서드 : 너가 코딩해서 써라~
  - 추상메서드에서 메서드가 호출됐다...?
    추상메서드에 상속받은 일반메서드가 분명히 있다는 뜻
    추상메서드를 호출했다? 일반메서드의 인스턴스를 호출한거니, 일반메서드 확인
  - 클래스가 같은 부모의 자식 -> 같은 메서드를 가짐 = 사용법이 같다
  - 추상클래스 선언은 언제 ? 직접 사용할 수 없는 경우에 사용

  - 해시 알고리즘
    해시 : 해시 값을 생성하는 식
    해시 값 -> 정수값이 클수록 해시 값이 중복될 가능성이 낮아진다
            -> 계산 시간은 증가 
  - 해시값을 가지고 파일을 비교하는 이유? -> 파일명이 원본과 저장한 파일명과 다를 수 있기 때문에

## 2021_08_12 (oop_ex09_d 시작)
  - [oop_ex09_e]
    인터페이스에 메소드를 추가하면 모든 하위 글에 영향을 끼침
    이럴 경우 해결 방안은 ? -> 상속을 이용.
      defalut 메소드를 이용해보자. 기존 클래스에 영향을 주지 않는다.
      defalut의 단점도 존재 -> 해당 메소드를 가지고 있지 않아도 컴파일 오류가 나타나지 않는다
  - 규칙을 다루는 static 메소드가 필요한 경우!!!!!인스턴스에 스태틱 메소드 만들 수 있다.
  - adapter 디자인 패턴 : 기존 패턴을 새 규칙에 맞춰서 재 설계하는 패턴

  * 인터페이스/추상클래스/어댑터패턴 => 끊임없이 나옴, 복습!!

## 2021_08_17
  - 인스턴스 멤버를 호출하려면 반드시 해당 클래스의 인스턴스 주소가 필요
  - 클래스 블록과 중첩클래스
  - 객체지향
    객체와 객체와의 관계를 읽혀라! 코드는 가지고 와도 된다
  - 컴파일이 끝나면 class파일로 추출되어 이미 끝난 상태 ($1 -> 첫번째 로컬클래스를 의미)
  - 메서드가 호출될때마다 클래스가 로딩된다 ? -> 절대 아님
    클래스 파일은 한번만 로딩된다!!!!!! => 클래스 파일 하나당 하나의 클래스가 로딩된다.

## 2021_08_18 (프로젝트 첫 발표, 프로젝트 방법론)
  - 방법론(methodology)
    어떤 사항에 대해 이론이나 경험적 사실을 정리하고 표준화한 것
    * 표준화 : 사람이나 조직에 상관없이 경험의 많고 적음에 상관없이
              일관된 수준의 결과무를 산출

  - 소프트웨어 개발 방법론
    소프트웨어(=결과물 ex)앱,서비스)를 생산 -> 프로그래밍 개발 과정을 정리
    ->개발과정을 표준화 -> 개인이나 조직에 상관없이
    일관성 있는 개발을 유지하고 협업을 수행할 수 있게 돕는 것
    * 교육 과정 프로젝트 수행에서 사용할 방법은?
      애자일 방법론 변형, 최소 산춘물, 프로그래밍에 초점 : 프로그래밍 경험을 높이자

  - 예)
      1. 폭포수 모델 
      2. 프로토타이핑
      3. 반복적, 점진적 개발
      4. 애자일 방법론

  - 교육과정 프로젝트 수행 절차
    1) 주제 선정 - 프로젝트 소개(현황 및 문제점, 해결방안 및 이점), UI 프로토타입
    2) 요구사항 식별 - 유스케이스 명세(액터,유스케이스 목록)
    3) DB모델링 - ER다이어그램, DDL SQL
    4) 구현할 기능 선정
    5) 구현 및 테스트 (4, 5번 반복 - 소스파일)
    6) 발표 - 발표자료

  * 요구사항 식별 방법론
    1. 액터 식별
      액터란? 시스템을 사용하는 사람 또는 프로세스(소프트웨어), 장치(하드웨어)
      주 액터: 시스템을 사용하는 액터
        보조 액터 : 시스템이 사용하는 다른 시스템

## 2021_08_19 (10-h -> 10-i, 10-i -> 11-a) ** 10 - i 에서 11-a 바꾸는 부분 **
  - Use-case 관계 : 포함과 확장
    1) 포함관계(include) - 메인 기능을 수행할때, 서브기능을 하고! 다시 메인기능을 수행
    2) 확장관계(extend) - 메인 기능을 수행할때, 메인기능을 멈추지 않아도 서브기능 수행

  - [10-i 추상클래스 적용]
    public abstarct claa
    AbstractList 추가부분 수정

  - ArrayList 에 remove 영역 연습

  ## 2021_08_20 ()
    - 알고리즘_date_structure 패키지 예제를 학습

  ## 2021_08_23 (제네릭 / java_basic_generic_ex01~ex02 / basic_ex03 / **oop_ex12_110~160(람다문법)** 로컬클래스를 지역클래스로 바꾸고 람다문법적용)
    - 형변환은 정확한 타입을 알고 해야함
    - 파라미터 값을 직접 생성하기 애매할때 간접설정
    - JVM 처리만 해줄 뿐..형변환을 해주지 않음

    - 제네릭의 타입을 적용할 경우 다형성을 생각하면 안된다.
    - 타입이 <?> 일땐, 어떤 코드는 OK/ 어떤 코드는 컴파일 오류가 된다.

  ## 2021_08_24 (로컬클래스-> 익명클래스로 바꾸기 -> 람다법칙)
    - oop_ex12_Exam0510~540 아주 중요한 코드
    - bsic_ex03_210~244번까지**

## 2021_08_25 
  - 인터페이스의 유용성을 다시 생각해보기(basic_ex04_0110)
    - 각자 다른 코드명으로 개발 -> ArrayList를 LinkedList로 교체하기가 쉽지 않다
      => 같은 역활을 하는 코드명이 달라서 변경하려면 코드를 많이 변경해야 한다.
    - 인터페이스를 사용하면?
       사용법이 같기 때문에 프로그래밍에 일관성을 부여 -> 유지보수가 쉬움
  - Stack - pop() : 제거
            peek() : 가지고 옴

## 2021_08_19
  - Use-case 관계 : 포함과 확장
    1) 포함관계(include) - 메인 기능을 수행할때, 서브기능을 하고! 다시 메인기능을 수행
    2) 확장관계(extend) - 메인 기능을 수행할때, 메인기능을 멈추지 않아도 서브기능 수행
  - ArrayList 에 remove 영역 연습
  - 스택을 언제 사용하는지, Q를 언제 사용하는지? *면접질문
    스택은 BreadCrumb을 구현할때 적합하다
    먼저 등록한걸 먼저 처리 - 예약처리- Q

## 2021_08_27 (git)
  - 메모리 부족 = 메모리 릭
  - 드림코딩 by 엘리 -> 깃,깃허브 제대로 배우기 동영상
  - 예외처리 try _ catch

## 2021_09_02 (Command 문법,HashMap 객체 이용)
  - Command 인터페이스를 생성 후 객체를 인터페이스에 연결해 간결히 정리한다.
  - MenuItem 생성 -> [inner 클래스 개념 복습 필요] 

## 2021_09_03
   - 비트연산자
   - 프로젝트 : 회원가입, 아이디찾기, 비밀번호찾기, 함께해요 게시판 구현 후 관리자페이지로 연동함
   - 비대면으로 프로젝트 발표를 했는데, 목소리가 너무 작게 들렸다고 해서 너무 아쉽다. 하지만 기회는 또 있지!

## 2021_09_06
  - 문의하기 : 본인이 쓴 글만 읽기 가능 -> 권한설정으로 처리 완료
               로그인을 하지 않으면 글을 작성할 수 없다.

## 2021_09_07 (데이터 입출력 : Date I/O Stream API / 흐름 알기!) 

## 2021_09_08
  - fuction이나 structure, class 등의 코드를 모아둔 파일 = '라이브러리(Library)' ex) *.dll / *.lib / *.so / *.jar
  - 링킹을 했을 때, *.exe 파일이 만들어 지는데 그 안에 파일정보만 포함된 파일이 있고(*.dll), 실행가능한 파일이 들어 있다.(*.lib)
    (java-basic_io_ex01_730 731 732 -> 740에서 연습)

## 2021_09_10 (Design pattern- Decorator 패턴) - 기존 기능 확장
  - 상속을 사용하지 않고 기존의 기능에 새 기능을 덧붙이는 방법
  - 추상메서더 Printer을 만들어 파라미터로 origin을 받아 사용하기
    - composit이랑 차이점:

## 2021_09_11 (프로젝트)
  - 글 작서자와 관리자만 글 읽기 가능
  - 문의사항 분류 선택하기 추가
  - 답변은 관리자만 닭기 가능
## 2021_09_12 (프로젝트)
  - 게시판 번호 관리 - int 값으로 자동적으로 부여하게 처리

## 2021_09_13
  - java-basic_io_ex10 -> 이부분이 실전 바로 적용내용

## 2021_09_14
  - serial 컴파일 할때, 변수들의 순서 변경 상관 없음, 변수명은 바뀌면 안됨, 변수명 추가도 안됨 
  - 데이터가 결함이 발생하지 않도록 'integrity'
  - MIME 타입

## 2021_09_15
  *offset*

## 2021_09_16
  - google-gson 라이브러리
  - 메타데이터 - JSON
  - AI 전문가 공부법 : 파이썬 -> 수학적 언어 (Core,Numpy) -> 기초수학 -> 딥러닝 -> 강화학습
  - 개발자가 해야 하는 인공지능 학습의 단계
    시각인지 -> 자연어 처리

## 2021_09_18
  - 프로젝트 진행
    - 모금함 총 기부 합계 수정
    - 각 챌린지에 달리는 댓글의 첫댓글의 댓글번호는 무조건 1로 시작 필요
    - 게시물의 조회수가 높은 순서대로 페이지에 출력

## 2021_09_19
  연휴다아,,, 오늘은
  어제 코딩한 부분 다시 복습 + 생성자 개념 정리

## 2021_09_20
  - 팀원들 만나 프로젝트 작업 진행
  - bitcamp study oop 부분 다같이 복습진행

## 2021_09_21
  - 오전엔 각자 공부, 오후엔 디코로 모여 복습
  - 추상메서드, 상속, 제네릭, ArrayList

## 2021_09_22
  - 게시글 안 삭제, 변경, 답글달기 적용
  - commandRequest 핸들러 적용

## 2021_09_23 (옵저버 패턴)
  - 관잘자 = 감시자
  - 보호관찰사와 가석방죄수의 관계
  - 보호관찰사 = obserber = listener : 죄수의 보고를 받는 입장, 실제적으로 보고를 받는.. -> listener
  - 가석방죄수 = 객체 = 옵저버 객체의 인스턴스(옵저버 객체의 주소를 가지고 있어야한다. 왜냐? 보고를 해야하잖아~그러니깐 주소를 가지고 있어야지!)
                        가석방죄수가 주소를 가지고 있다. 관찰자는 가지고 있지 않아!

## 2021_09_24 (이클립스 환경설정 다시 복습)
  - 프로젝트 발표(챌린지 부분)
  - DBMS 1/2

## 2021_09_25
  - 문의하기 관리자 답글 관리여부 회의
  - ArrayList

## 2021_09_26
  - 개인적으로 프로젝트 작업함

## 2021_09_27
  - WAN <-> WAN : internet
  - NIC = RAN카드
  - RAM카드를 통해 데이터를 주고 받는다
  - 통신할 대상을 램카드로 보내주는 객체가 있는데 그것이 바로 'socket'
  - socket의 고유번호가 있는데 그것이 바로 port번호! port번호가 필요한 이유는? 

## 2021_10_01 (Thread)
  - dao패키지(★★★) - 그림참고

## 2021_10_05 (MariaDB 설치, 사용자/DB 생성) ☆
   - DBMS : Datebase를 조작하는 S/W  ex)Oracle, MySQL, DB2, MS-SQL, Alitibase, Tibero ...등
   - SQL : 데이터 처리요청을 작성하는 문법
   - MariaDB 설치 : eomcs_docs_dbms / 환경변수 설정

   
   - SQL테스트 준비
   - 테이블 생성 : eomcs_docs_sql

  > create table test01(
      no int not null,
      name varchar(20) default 'noname',
      age int default 20
    ); 후
  > insert into test01(no, name, age) values(1, null, null); 
    - name, age 값에 디폴트값이 들어가는게 아니라 null 값이 들어간다!!


## 2021_10_06 (MariaDB 요청 경로, SQL) ☆
  - DDL : 데이터를 저장하고 다룰 DB객체(Table,View,Procedure,Function...)를 정의한다.
  - DQL/DML : DB객체의 데이터를 다룬다.

   * DBMS *
  - 데이터를 저장하려면 먼저 테이블을 만든다. (테이블명,항목,항목들의 데이터 타입 정의 후 테이블 생성)
  - insert into test1(no,name) values(1, 'aaa'); // 테이블의 no,name 순서대로  1과 aaa를 넣어라
  - select * from test1; // test1에 있는 모든 컬럼의 데이터를 출력하라
  - insert into test1(no, name) values(null, 'bbb'); // 행의 값 추가, 
  - insert into test1(no, name) values(null, null); // 값을 입력 했지만, 칸이 비워져있는 상태

  * Key *
  - 여러개의 Key값들 중, DB관리자가 주 키로 결정한 Key = Primary Key
  - 여러개의 Key 값들 중 주 키로 선정되지 않은 나머지 후보 Key(대안키) = Alternate Key 
  - 마땅히 사용할 Key가 없는 경우 -> 임의의 컬럼을 만들어 PK로 지정한다 = Artificial Key(인공키) ex) 게시글번호, 일련번호
  - Primary key : 기본이 not null
  - PK 처럼 제약을 줘서 중복을 막는 문법 [UNIQUE]
  - view가 참조하는 테이블에 데이터를 입력한 후 view를 조회하면?
    => 새로 추가된 컬럼이 함께 조회된다.
  
## 2021_10_07 => SQL 이게 Point!!!!!!
  - select

## 2021_10_08 (Join, DBMS, JDBC 프로그래밍, )
  - 1) cross 조인(카티션 곱)
  - 2) natural 조인
  - 왜 데이터를 가져올 때 여러 테이블의 데이터를 결합해서 꺼내는가?
    => 데이터 중복을 피하기 위해 데이터가 여러 테이블에 분산되어 있기 때문에
  
  * 질문 : JDBC 와 JDBC Driver 의 차이점은?
  
  - 드라이버와 DBMS 관계

## 2021_10_11
  - SQL 10/05, 10/06 부분 복습
  - 디스코드 모여 팀별 프로젝트 진행

## 2021_10_12 (JDBC / java-basic_jdbc_ex1~ex4)
  - JDBC 버전을 쉽게 수정 : jdbc-driver.properties 에 사용할 버전 수정

## 2021_10_13 (SQL삽입공격, DB모델링)
  - encoding <-> decoding : 규칙에 따라 변환
  - software as a service[Saas] : 소프트웨어를 설치하지 말고 그 자체로 사용하는 것
  - ex03 비밀번호에 숫자값만 입력할 수 있게 하는 코드 참고할 수 있다
  - 데이터가 들어갈 자리에 SQL코드를 함께 넣어서 원래 만들려고 하는 문장을 공격한다 => SQL삽입 공격
  - 정보를 2개의 테이블에 분산해 저장한다면, 2개의 테이블에 정상적으로 데이터가 저장되어야만 유효하다.
    => 이렇게 묶어서 다뤄야 하는 작업을 [transaction] 이라 한다. = 한개의 업무를 가르키는 단위 = 여러개의 작업을 한 단위로 다루는 경우
       ex) 회원정보입력, 물품 구매하기, 자동차 보험가입, 수강신청, 멤버탈퇴
  - 데이터가 중복되지 않게 정리를 해야한다 => [데이터 모델링]

## 2021_10_14 (DBModeling)
  - 엔티티 = 릴레이션 = 테이블
  - 테이블을 구성하는 값 => 속성(attribute) = 컬럼(column)
  - PrymeryKey는 한번 설정 후 사용하면 바꿀 수 없다.

## 2021_10_15 (DBModeling_feedback)
  - 다이어그램 추가 후 각 다이어그램 성격에 맞게 테이블 정렬
  - 포인트를 가지고 등급을 부여한 후, 금전적인 연관이 있을땐 테이블을 따로 분리한다.
  - 알람설정
  - 계층형 게시판은 한 테이블에서 관리를 하고 출력 부분에서 특정 조건을 걸어 특정조건만 보이게한다.
  - 팀장은 권한이 아니고 역활(roll)이므로, (A에선 팀장이지만, B에선 팀장이 아니다)
  - 승인여부에 따라서 멘토가 정해짐 -> 신청서 날림
  - 100번 회원이 1000번 유료회원 신청
    100번 회원이 또 다시 1000번 유료신청 불가 -> 회원번호, 유료스터디 Primary Key로 설정
  - 결제 상태 : 결제 취소(2), 결제완료(1) 상태 나타냄 -> 1인 상태만 멘티 권한
  - DB로 추출해 사용하지 않는다면, 컬럼으로 나누지 않아도 된다.

## 2021_10_19 (jdbc 변경)
  - 하루종일 jdbc로 변경함
  - 하다보니 DB모델링에서 한번 잘못하면 처음부터 다시 해야한다는 걸 깨달음
  - DB설계가 정말 중요하구나.. 전회사 개발자분들이 DB설계 준비가 안되어있으면 작업진행을 안했었던 이유를 드디어 깨달았다.

## 2021_ 10_20 (Mybatis Framework)
  - 팀별 프로젝트 진행(jdbc->mybatis로 수정)

## 2021_10_21 ()
 - 쌍방참조

## 2021_10_22

## 2021_10_23
  - 디코모여 프로젝트 진행
  - 단체, 기관 로그인 코드 작업 (관리자가 승인하는 건 아직 못함)

## 2021_10_24
  - 디코모여 프로젝트 진행
  - 첨부파일 연결 해결 못함...하 ㅠㅠ

## 2021_10_25 (웹 / 실전프로젝트2.pdf)
  - 웹프로그램이 왜 나타나게 되었나..?
    - 시대가 변하면서 시스템 기능변경이 잦아짐 -> App 재설치가 잦아짐-> 유지보수 어려움
  - Web Application Server = WAS : 개발자가 통신프로그램을 만질필요가 없음
  - 웹 서버와 애플리케이션을 연결할 표준화된 기술이 필요 -> Servlet기술이 나타남
  - Servlet(서블릿) : Server Application + 작은조각(let)
    : web server와 연동하고 표준적인 방법을 정의한 것
  - JavaEE(Enterprise Edition), Implements(구현체:JavaEE명세서에 따라 만든 서버)
  - 프로램 버전에 맞게 언어를 사용하고, 개발해야 한다.
  - Tocat서버 준비(9.xx)ㄹ 
    - 1) Servlet container 설치
    - 2) Elipse에서 톰캣서버를 제어할 수 있도록 설정(windows-prepernce-server-runtime xxxx-Tomcat9.0 버전 선택(고객사가 사용하는 버전을 선택하면 됌))
    - 3) 웹프로젝트에서 톰캣서버에서 실행할 수 있도록 환경설정()

## 2021_10_26 (웹)

## 2021_10_27 (HTML5)
  - 크롤링: 완성된 페이지 HTML소스를 가지고 작업하는 방식
  - get방식(요청) : 데이터를 조회할 때 사용 
  - post방식(요청) : 데이터를 보내는 형식에 보통 사용

## 2021_10_28 (JSP)

## 2021_10_29 (Servlet,JSP 웹 애플리케이션 아키텍처(실전프로젝트3.pdf))
  - 저장소 (ServletRequest)
  - HttpSession 저장 : 로그인 사용자 정보
  - JSP Controller :  

## 2021_11_01(CSS)

## 2021_11_2 (자소서특강)
  - 자기소개서 할 때 첫번째로 해야하는 일
   1) 자기소개서 문항 분석
  - 업부 또는 여러 활동을 수행하면서, 원활하게 진행하기 어려운 상황, 어떤 절차와 방법으로 극복
    -> 처음 자기가 맡은 파트대로 일을 작업하다보니 자기 주관이 뚜렷한 방향으로 작업물이 완성되어져갔다.
       그 일을 접한 후 결정을 해야하는 경우 무조건 팀원들을 다 불러 다 같이 의견을 나누고 일을 진행함
  - 의사표현 방법이나 방식을 기술 -> 이 부분에 집중해서 작성
  - 직무지원동기 -> 변별력이 없음, 글자수에 최대한 맞게 작성
  - 과제를 수행하며 본인의 부족한 점을 발견하고 이를 개선-> 자기개발능력, 직무지원동기
  - 공통의 목표달성 -> 팀워크
  - 본인의 노력을 작성 -> 직무역량,지원동기,자기개발능력
  - 대화에서 서로의 의견이 너무 다른 경우 어떻게 해결 -> 의사소통능력

  - 경험기반 -> 본인이 주로 담당하는 역활
  - 소제목 : 추상적인 말 금지/ 내용과 연관성이 있어야함

## 2021_11_03 (bootstrap)
  - 설정된 node_modules 가져오기 : npm init
  - 안에 import된 파일들 가져오기 : npm install

## 2021_11_04 (JavaScript(eomcs-servlet_webapp_javascript_ex00~ex02))
  - 기본문법 {
      변수
      연산자와 제어문
      함수와 객체
  }
- HTML VS App
- use strict; 선언하고! 문법작성하기
  <script>의 제일 첫번째에 작성해야한다.

## 2021_11_08 (JaaScript(eomcs-servlet_webapp_javascript_ex05~) / ex06!!!!!부터 바로사용가능)
  - 게시판 선택시 넘어가는 방법 : 총 3가지이다.
  - 라인클릭 시 전체선택하기

## 2021_11_09 (servlet, Filter, Listener)
  - 들어온 요청의 servlet의 실행여부를 결정할 때 [Filter]
  - 들어온 요청의 단순 보고용 / servlet의 영향을 주지 못한다. [Listener]
  - 입력폼 요청은 메서드 post요청을한다. 
    이때 getParameter 인코딩을 선언해 줘야 한다.[req.setCharacterEncoding("UTF-8");]
    get요청인경우는 따로 선언을 안해도 된다(Tomcat7 기준. 이전버전은 깨짐)

## 2021_11_10 (fileUpload/썸네일)
  - GET요청 VS POST요청 (servlet_ex04)

## 2021_11_11 (servlet refresh)

## 2021_11_12 (Spring
- class명 뒤에 Factory로 끝나면 긴장하라.
  - 메서드 2개를 구현해야한다. getObject(), class<?>

## 2021_11_18 (Spring webMVC)
  - 

## 2021_11_19 (REST API VS 웹 프로그램 면접질문 예상답변)

## 2021_12_14 (자소서 수정, 면접준비)

## 2021_12_17 (면접준비)
 







# bitcamp-20210621

## 1일차(2021-06-28,월)
- 교육과정의 목표: 웹 개발자 역량 습득
- 웹 개발자의 진로: SI/SM, 스타트업, 서비스, 공사 등
- 소프트웨어 개요
	- System S/W, Application S/W
	- Standalone, Client/Server, Web Application
	- Web application 구성 요소: Java App, HTML/CSS/JavaScript
	- Back-end 개발: Java Application을 작성할 때 사용되는 기술 개요
	- Front-end 개발: HTML/CSS/JavaScript 기술 개요
- 프로그래밍 도구 준비
	- WebEx 온라인 화상 통신 설치
	- github.com 계정 생성
	- github.com에 개인 저장소 생성
	- 강사의 저장소 가져오기
	- 저장소에 추가된 파일 가져오기

## 2일차(2021-06-29,화)
- 프로그래밍 도구 준비(계속)
	- git 저장소 다루기
		- git 서버 저장소를 로컬로 복제
		- 작업 파일을 로컬 저장소에 백업
		- 로컬 저장소의 내용을 서버 저장소에 업로드
		- 서버 저장소의 변경 내용을 로컬 저장소로 가져오기
	- VSCode 편집기 설치
	- mingw64 윈도우 gcc 컴파일 설치
	- node.js 자바스크립트 인터프리터 설치
- 프로그램 만들고 실행하기
	- 컴파일 방식
		- C 언어로 "Hello, world!" 를 출력하는 프로그램 만들기 
		- 소스와 기계어, 컴파일, 컴파일러의 관계
		- 기계어란? 
			- CPU instruction set
			- 기계어와 CPU의 관계
			- 기계어와 OS의 관계
	- 인터프리터 방식
		- JavaScript 언어로 "Hello, world!" 를 출력하는 프로그램 만들기

## 3일차(2021-06-30,수)
- 프로그래밍 도구 준비(계속)
	- Java 11 JDK 설치
		- JAVA_HOME 환경 변수 설정
		- PATH 환경 변수 설정
- 프로그램 만들고 실행하기(계속)
	- 컴파일 방식과 인터프리터 방식 비교
		- 프로그래밍 언어와 컴파일, 컴파일러
	- 자바의 프로그래밍 방식 소개
		- 컴파일과 실행
- 자바 애플리케이션 프로젝트 폴더 준비
	- 애플리케이션과 프로젝트의 관계
	- git 저장소에서 프로젝트 관리하기
		- 1단계: 소스파일과 .class 파일을 구분하지 않는다.
		- 2단계: src 폴더와 bin 폴더를 사용하여 소스 파일과 .class 파일을 분리한다.
		- 3단계: Maven 프로젝트 표준 디렉토리 구조
		- 4단계: git 저장소에 여러 개의 프로젝트 두기
- 수업 자료 준비하기
	- 자바 프로그래밍 기본 문법 예제
		- https://github.com/eomcs/eomcs-java
	- 개발 도구 설정 및 사용 안내서 
		- https://github.com/eomcs/eomcs-docs
	- 서블릿/JSP 예제
		- https://github.com/eomcs/eomcs-java-web
	- Spring 프레임워크 예제
		- https://github.com/eomcs/eomcs-spring-webmvc
	- 미니 프로젝트 관리 시스템 단계별 구현 예제
		- https://github.com/eomcs/eomcs-java-project-2021

## 4일차(2021-07-01,목)
- 프로그래밍 도구 준비(계속)
	- Gradle 설치
		- PATH 환경 변수 등록
- 프로젝트 관리
	- 애플리케이션과 프로젝트
	- 루트 프로젝트와 서브 프로젝트
	- 프로젝트와 작업
	- 프로젝트 산출물을 보관하기 위한 디렉토리 구조
	- 팀 프로젝트와 깃 저장소
	- 깃 저장소로 프로젝트를 관리하는 다양한 유형
- 교육 과정 진행 
	- 이론과 실전 프로젝트를 병행하여 학습
	- 실전 프로젝트(study-project)의 로드맵
- 빌드 도구
	- 빌드 도구 개요
	- 다양한 빌드 도구: Ant, Maven, Gradle
	- Gradle 빌드 도구를 이용하여 프로젝트 폴더 준비
		- `gradle init`
	- Gradle 빌드 도구로 생성한 디렉토리의 구조 및 파일 설명
- Gradle 빌드 도구 사용법
	- 빌드 스크립트 파일의 용도
		- settings.gradle : 여러 프로젝트에 공통으로 적용할 설정 정보.
		- app/build.gradle : 서브 프로젝트에만 적용하는 빌드 설정 정보.
	- Gradle 기본 작업
		- init : 현재 폴더를 프로젝트 폴더로 구성
		- wrapper : Gradle 설치 및 실행 파일 생성
		- gradle에 플러그인을 장착하면 더 많은 작업을 수행할 수 있다.
	- 'java' gradle 플러그인  
		- compileJava
			- src/main/java 폴더에 있는 소스 파일을 모두 컴파일
			- build/classes/java/main 폴더에 .class 파일을 둔다.
		- compileTestJava
			- src/test/java 폴더에 있는 소스 파일을 모두 컴파일
			- build/classes/java/test 폴더에 .class 파일을 둔다.
		- processResources
			- src/main/resources 폴더에 있는 파일을 build/resources/main 폴더에 복사한다.
		- processTestResources
			- src/test/resources 폴더에 있는 파일을 build/resources/test 폴더에 복사한다.
		- clean
			- build 폴더를 삭제한다.
		- classes
			- compileJava와 processResources를 모두 수행
		- testClasses
			- classes + compileTestJava + processTestResources 수행
		- check
			- test + 단위 테스트 수행
		- javadoc
			- 소스 파일에서 javadoc 주석을 추출하여 HTML된 API 문서를 생성한다.
		- build
			- check + assemble(배포 파일 생성 작업) 수행
	- 'application' gradle 플러그인  	
		- run
			- 'java' 플러그인의 classes 작업을 먼저 실행한다.
			- 그런 후 application 설정에 지정한 클래스를 실행한다.
		- build
			- 이 플러그인을 장착한 상태에서 build 작업을 수행하면 고객에게 배포할 수 있는 파일을 build/distributions 폴더에 생성한다.
			- 자바 프로그램을 실행시킬 수 있는 스크립트 파일도 자동 생성된다.
	- 정리
		- 1) init 작업을 통해 프로젝트 폴더를 준비한다.
		- 2) build.script에 빌드 작업이 들어 있는 플러그인을 설정한다.		
		- 3) 각 플러그인의 작업을 실행할 때 필요한 정보를 등록한다.
		- 4) 프로젝트에서 사용할 외부 라이브러리 파일을 등록한다.
		- 5) 필요한 작업을 실행하여 애플리케이션을 빌드한다.
- 실전 프로젝트(eomcs-java-project)
	- 01-a. 프로젝트 준비하기 : Gradle 빌드 도구를 활용한 자바 프로젝트 구성

## 5일차(2021-07-01,금)
- 프로그래밍 도구 준비(계속)
	- eclipse.org 에서 개발 도구 다운로드 및 설치
	- eclipse IDE 환경 설정    
		- eomcs-docs/devtool/개발도구준비.md 파일 참조
- git 다루기
	- 로컬 저장소 만들기
		- `git init`
	- 서버 저장소 만들기 
		- `github.com`에서 new 버튼 클릭
	- 로컬 저장소에 서버 저장소의 위치를 등록하기
		- `git remote origin 서버저장소URL`
	- 로컬 저장소의 내용을 서버에 올리기
		- `git push`
- 자바 기초 문법(eomcs-java/com.eomcs.lang)
	- ex01
		- 패키지 다루기
		- 자바 소스 파일과 클래스 블록
		- 소스 파일의 인코딩
		- main() 메서드
	- ex02
		- 여러 줄 주석, 한 줄 주석
		- javadoc 주석
		- 애노테이션
- 실전 프로젝트(eomcs-java-project)
	- 01-b. 프로젝트 준비하기 : `이클립스 IDE`로 임포트

## 6일차(2021-07-05,월)
- 프로그래밍 도구 준비(계속)
	- VSCode Live 확장 팩 플러그인 추가
	- 라이브 코딩 작업 테스트
- 자바 기초 문법(eomcs-java/com.eomcs.lang)
	- ex99
		- 콘솔 출력 다루기: print(), println(), printf()
	- ex03
		- 리터럴 표기법 요약 정리
		- 값을 메모리에 저장하는 방법: RAM, HDD
		- 10진수, 8진수, 2진수, 16진수 표기법
		- 정수를 2진수로 저장하는 방법
		- 메모리 크기에 따른 값의 범위
- 실전 프로젝트(eomcs-java-project)
	- 02-a. 값 다루기 : 리터럴과 콘솔 출력

## 7일차(2021-07-06,화)
- 프로그래밍 도구 준비(계속)
	- VSCode Hex Editor 플러그인 추가
	- .class 파일을 16진수 값으로 보기 : 부동소수점이 2진수로 표현됐을 때의 2진수 값 확인
- 자바 기초 문법(eomcs-java/com.eomcs.lang)
	- ex03
		- 부동소수점을 2진수로 표현하는 방법: IEEE 754 명세
		- 문자를 2진수로 표현하는 방법: ASCII, ISO-8859-2, EUC-KR, 조합형, Unicode, UTF-8 문자 집합 소개
		- 이스케이프 문자를 다루는 방법
		- Raster 폰트(그림)과 Vector 폰트(그림) 비교 
		- 줄바꿈 코드: 0D(Carrage Return; CR), 0A(Line Feed; LF)

## 8일차(2021-07-07,수)
- 자바 기초 문법(eomcs-java/com.eomcs.lang)
	- ex04
		- 변수와 변수 선언: 데이터 타입과 변수명
		- primitive data type: byte, short, int, long, float, double, boolean
	- ex99
		- Scanner 를 이용하여 키보드 입력 다루기
- 실전 프로젝트(eomcs-java-project)
	- 02-b. 값 다루기 : 변수와 키보드 입력

## 9일차(2021-07-08,목)
- 자바 기초 문법(eomcs-java/com.eomcs.lang)
	- com.eomcs.lang.ex04
		- 배열 다루기
	- com.eomcs.lang.ex06
		- if, if ~ else 
		- while, for
- 자바 기본 클래스(eomcs-java/com.eomcs.basic)		
	- com.eomcs.basic.ex10
		- java.util.Date 클래스 사용법
		- java.sql.Date 클래스 사용법
- 실전 프로젝트(eomcs-java-project)
	- 02-c. 값 다루기 : 배열과 흐름 제어문 활용

## 10일차(2021-07-09,금)
- 자바 기초 문법(eomcs-java/com.eomcs.lang)
	- ex04: 배열 다루기(계속)
	- ex05: 연산자 사용법

## 10일차(2021-07-09,금)
- 자바 기초 문법(eomcs-java/com.eomcs.lang)
	- ex04: 배열 다루기(계속): 배열 레퍼런스와 오프셋 주소
	- ex05: 연산자 사용법

## 11일차(2021-07-12,월)
- 자바 기초 문법(eomcs-java/com.eomcs.lang)
	- ex05: 연산자 사용법(계속) : 비트 이동 연산자
	- ex06: 조건문, 반복문
- 실전 프로젝트(eomcs-java-project)
	- 03-a. 메서드 사용법 : 프로그램의 시작점(entry point), `main()`, 조건문, 반복문

## 12일차(2021-07-13,화)
- 실전 프로젝트(eomcs-java-project)
	- 03-b. 메서드 사용법 : 메서드 활용

## 13일차(2021-07-14,수)
- 자바 기초 문법(eomcs-java/com.eomcs.lang)
	- ex07
		- 메서드 활용
		- call by value 와 call by reference
		- JVM의 메모리 영역: Method Area, JVM Stack, Heap
		- 클래스의 인스턴스 메모리
		
## 14일차(2021-07-15,목)
- 자바 기초 문법(eomcs-java/com.eomcs.lang)
	- ex07
		- 메서드에서 new 연산자를 사용하여 변수를 만들기: Heap 영역
		- 재귀호출과 스택 오버플로우
		- main() 메서드와 프로그램 아규먼트
		- JVM 아규먼트
- 알고리즘 (com.eomcs.algorithm)
	- quiz: Test001 ~ Test004

## 15일차(2021-07-16,금)
- 실전 프로젝트(eomcs-java-project)
	- 04-a. 클래스 사용법 : 메서드 분류
	- 04-b. 클래스 사용법 : 새 데이터 타입 정의 
	- 04-c. 클래스 사용법 : 패키지로 클래스 분류

## 16일차(2021-07-19,월)
- 실전 프로젝트(eomcs-java-project)
	- 04-d. 클래스 사용법 : 의존 관계
	- 05-a. 인스턴스 사용법 : 클래스 필드와 클래스 메서드의 한계
	- 05-b. 인스턴스 사용법 : 인스턴스 필드가 필요한 이유와 사용법

## 17일차(2021-07-20,화)
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex02
		- 스태틱 필드, 인스턴스 필드, 로컬 변수 비교와 활용
		- 스태틱 메서드, 인스턴스 메서드 비교와 활용

## 18일차(2021-07-21,수)
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex00: 스태틱 필드/인스턴스 필드, 스태틱 메서드/인스턴스 메서드
- 실전 프로젝트(eomcs-java-project)
	- 05-c. 인스턴스 사용법 : 인스턴스 메서드가 필요한 이유와 사용법
	- 06-a. CRUD 구현하기 : 게시글 상세보기/변경

## 19일차(2021-07-22,목)
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex00: 스태틱 필드/인스턴스 필드, 스태틱 메서드/인스턴스 메서드 활용 연습
- 실전 프로젝트(eomcs-java-project)
	- 06-a. CRUD 구현하기(계속) : 게시글 삭제

## 20일차(2021-07-23,금)
- 실전 프로젝트(eomcs-java-project)
	- 06-a. CRUD 구현하기(계속) : 회원/프로젝트/작업 CRUD 완성
	- 06-b. CRUD 구현하기 : 리팩토링

## 21일차(2021-07-26,월)
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex01: 객체지향 문법 개요
- 실전 프로젝트(eomcs-java-project)
	- 07-a. 의존 객체 다루기 : 인스턴스 필드에 직접 주입
	- 07-b. 의존 객체 다루기 : 생성자로 주입

## 22일차(2021-07-27,화)
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex03: 인스턴스 멤버와 스태틱 멤버 사용법

## 23일차(2021-07-28,수)
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex04: 인스턴스 멤버와 스태틱 멤버 활용예
	- ex05.a ~ g : 상속 문법

## 24일차(2021-07-29,목)
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex05: h ~ * : 상속 문법(계속)
	- ex06: a ~ c : 다형성(다형적 변수, 오버로딩, 오버라이딩)

## 25일차(2021-07-30,금)
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex06: c ~ * : 다형성(다형적 변수, 오버로딩, 오버라이딩)(계속)
	- ex08: a ~ b : 캡슐화(private, (default), protected, public)
- 실전 프로젝트(eomcs-java-project)
	- 07-a. 의존 객체 다루기 : 인스턴스 필드에 직접 주입
	- 07-b. 의존 객체 다루기 : 생성자로 주입

## 26일차(2021-08-02,월)
- 실전 프로젝트(eomcs-java-project)
	- 08-a. `Composite` 디자인 패턴 : 적용 전
	- 08-b. `Composite` 디자인 패턴 : 적용 후

## 27일차(2021-08-03,화)
- 실전 프로젝트(eomcs-java-project)
	- 08-b. `Composite` 디자인 패턴 : 적용 후(계속)
	- 08-c. `Composite` 디자인 패턴 : 익명 클래스 활용
	- 08-d. `Composite` 디자인 패턴 : 스태틱 멤버를 인스턴스 멤버로 전환

## 28일차(2021-08-04,수)
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- 상속 관계가 있는 클래스의 레퍼런스와 인스턴스
- 실전 프로젝트(eomcs-java-project)
	- 09-a. 데이터 처리 코드를 캡슐화 : 캡슐화 전 - 배열 크기 변경
	- 09-b. 데이터 처리 코드를 캡슐화 : 캡슐화 전 - 연결리스트 적용

## 29일차(2021-08-05,목)
- 실전 프로젝트(eomcs-java-project)
	- 09-c. 데이터 처리 코드를 캡슐화 : 캡슐화 수행
	- 09-d. 데이터 처리 코드를 캡슐화 : 캡슐화 후 -  배열 크기 변경
	- 09-e. 데이터 처리 코드를 캡슐화 : 캡슐화 후 -  연결리스트 적용
	- 10-a. 리팩토링 : Generalization
	- 10-b. 리팩토링 : Generalization II

## 30일차(2021-08-06,금)
- 실전 프로젝트(eomcs-java-project)
	- 10-c. 리팩토링 : ArrayList를 직접 사용하기
	- 10-d. 리팩토링 : LinkedList를 직접 사용하기
	- 10-e. 리팩토링 : Generalization + 다형성 + 의존 객체 주입(Dependecy Injection)
	- 10-f. 리팩토링 : 메서드 이동
	- 10-g. 리팩토링 : 인터페이스 적용
	- 10-h. 리팩토링 : 세터(setter), 게터(getter) 적용

## 31일차(2021-08-09,월)
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex07: 추상 클래스와 추상 메서드
- 자바 기본 클래스 사용법(eomcs-java/com.eomcs.basic)
	- ex01: Object 클래스 사용법

## 32일차(2021-08-10,화)
- 자바 기본 클래스 사용법(eomcs-java/com.eomcs.basic)
	- ex01: Object 클래스 사용법(계속)
	- ex02: String 클래스 사용법
- 프로젝트 팀 결정 및 A/B 반 결정
	- 1 팀(A반) : 김태호,조주리,신현지,김진현
	- 2 팀(A반) : 김은채,전예린,송다혜,조솔,우형민
	- 3 팀(A반) : 반계령,배서연,하선영,김제이,김주창
	- 4 팀(B반) : 변민성,위정욱,박성준,구백연,이지호
	- 5 팀(B반) : 최보균,이혜연,방우주,이서은,조대희
	- 6 팀(B반) : 윤수민,이용진,홍지현,문세철
- 팀원 자리 배치 결정
- 팀 프로젝트 절차 소개
	- 프로젝트 주제 선정
		- 1차: 두 개 주제를 선정해서 소개
			- 프로젝트 설명(PPT)
				- 프로젝트명
				- 현황 및 문제점: 현재 해당 업무나 일을 처리하는 상황과 그에 따른 불편한 점
				- 해결방안 및 이점: 어떻게 해결할 것인지에 대한 목표와 그에 따른 사용자의 이점
			- UI 프로토타입 작성
				- 무료 웹 서비스를 이용하여 UI 프로토타입 작성
				- 프로젝트로 만들려는 서비스를 분명하게 공유하기 위함
		- 2차: 한 개 주제를 선정해서 상세하게 소개
			- 프로젝트 설명 개정
				- 기존 설명 보완
			- UI 프로토타입 상세화 
				- 기존 UI 프로토타입 보완
	- 요구사항 정의
		- 액터 식별 및 정의
		- 유스케이스 식별 및 정의
		- 유스케이스 명세서 작성
	- DB 모델링
		- ER 다이어그램 작성
		- 데이터베이스 생성 및 테이블 생성
	- 구현 
		- 애플리케이션 구현
	- 발표

## 33일차(2021-08-11,수)
- 자바 기본 클래스 사용법(eomcs-java/com.eomcs.basic)
	- ex02: Wrapper, Date, Calendar 클래스 사용법
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex09(a1 ~ c): 인터페이스 문법

## 34일차(2021-08-12,목)
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex09(d ~ h): 인터페이스와 추상 클래스의 협업, 인터페이스 활용

## 35일차(2021-08-13,금)
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex09(i ~ j): 인터페이스 활용
	- ex11(a ~ c:Exam0240): 중첩 클래스 사용법
	
## 36일차(2021-08-17,화)
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex11(c:Exam0310 ~ e): 중첩 클래스, 로컬 클래스 사용법

## 37일차(2021-08-18,수)
- 팀 프로젝트 
	- 1차: 프로젝트 주제 발표
		- 반계령,배서연,하선영,김제이,김주창(2개)
			- 당근마켓, 스터디위더스
		- 김태호,조주리,신현지,김진현(1개)
			- 멘탈케어
		- 변민성,위정욱,박성준,구백연,이지호(1개)
			- 봉사와 기부
		- 윤수민,이용진,홍지현,문세철(2개)
			- 그룹웨어, 주류파인더
		- 김은채,송다혜,조솔,우형민(2개)
			- 1인레시피, 나만의스터디
		- 최보균,이혜연,방우주,이서은,조대희(2개)
			- IN-APT, 오늘의손
- 프로젝트 개발 방법론
	- 요구사항 식별 방법
		- 액터와 유스케이스 식별 방법

## 38일차(2021-08-19,목)

- 프로젝트 개발 방법론
	- 요구사항 식별 방법
		- 액터와 유스케이스 식별 방법(계속)
- 실전 프로젝트(eomcs-java-project)
	- 10-i. 리팩토링 : 추상 클래스 적용
	- 11-a. 자료 구조 다루기 : 스택 구현과 사용

## 39일차(2021-08-20,금)

- 실전 프로젝트(eomcs-java-project)
	- 11-b. 자료 구조 다루기 : 리팩토링 - 클래스 및 패키지 이동
	- 11-c. 자료 구조 다루기 : 제네릭이 필요한 이유와 사용법
	- 11-d. 자료 구조 다루기 : 자바 컬렉션 API 사용하기
- 프로젝트 개발 방법론
	- 요구사항 식별 방법
		- 액터와 유스케이스 식별 방법(계속)
- 과제
	- com.eomcs.algorithm.data_structure 패키지의 예제를 학습
	- 각 스텝의 예제 파일을 따라하면서 학습할 것.
- 팀 프로젝트
	- 요구사항 정의: Usecase Model
		- 액터 다이어그램
		- 유스케이스 다이어그램
		- 핵심 유스케이스의 UI 프로토타입

## 40일차(2021-08-23,월)

- 제네릭 문법(eomcs-java/com.eomcs.generic)
	- ex01 ~ ex02: 제네릭 사용법
- 자바 컬렉션 API(eomcs-java/com.eomcs.basic)
	- ex03: ArrayList 사용법
- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex12(Exam0110 ~ Exam0160): 람다(lambda) 기본 사용법
- 팀 프로젝트
	- 요구사항 정의: Usecase Model(계속)

## 41일차(2021-08-24,화)

- 자바 객체지향 문법(eomcs-java/com.eomcs.oop)
	- ex12(Exam0210 ~ ): 람다(lambda) 기본 사용법
- 자바 컬렉션 API(eomcs-java/com.eomcs.basic)
	- ex03: ArrayList 사용법(계속)

## 42일차(2021-08-25,수)

- 자바 컬렉션 API(eomcs-java/com.eomcs.basic)
	- ex04 ~ ex06: LinkedList, Stack, Queue, Deque
- 팀 프로젝트 
	- 2차: 최종 프로젝트 주제 선정 발표 및 요구사항 모델 발표
		- 내용
			- 액터 다이어그램
			- 유스케이스 다이어그램
			- UI 프로토타입
		- 발표 순서
			- 윤수민,이용진,홍지현,문세철
				- 주류파인더
			- 최보균,이혜연,방우주,이서은,조대희
				- MySeoul
			- 반계령,배서연,하선영,김제이,김주창
				- 스터디위더스
			- 변민성,위정욱,박성준,구백연,이지호
				- 행복하share
			- 김은채,송다혜,조솔,우형민
				- 오늘의 공부
			- 김태호,조주리,신현지,김진현
				- APUJIMA

## 43일차(2021-08-26,목)

- 자바 컬렉션 API(eomcs-java/com.eomcs.basic)
	- ex07 ~ ex08: HashSet, HashMap, Hashtable

## 44일차(2021-08-27,금)

- 팀 프로젝트 
	- 3차: 중간 구현 점검
		- 발표 순서
			- 최보균,이혜연,방우주,이서은,조대희
				- MySeoul
			- 반계령,배서연,하선영,김제이,김주창
				- 스터디위더스
			- 변민성,위정욱,박성준,구백연,이지호
				- 행복하share
			- 김은채,송다혜,조솔,우형민
				- 오늘의 공부
			- 김태호,조주리,신현지,김진현
				- APUJIMA
			- 윤수민,이용진,홍지현,문세철
				- 주류파인더
- 실전 프로젝트(eomcs-java-project)
	- 12. 예외가 발생했을 때 시스템을 멈추지 않게 하는 방법

## 45일차(2021-08-30,월)

- 예외처리(eomcs-java/com.eomcs.exception)
- 실전 프로젝트(eomcs-java-project)
	- 13-a. 사용자 인증 : 로그인
	- 13-b. 사용자 인증 : 내 정보 보기 
	- 13-c. 사용자 인증 : 로그아웃
	- 13-d. 사용자 인증 : 로그인 여부에 따라 메뉴 출력 제어

## 46일차(2021-08-31,화)

- 예외처리(eomcs-java/com.eomcs.exception)(계속)
- 실전 프로젝트(eomcs-java-project)
	- 13-d. 사용자 인증 : 로그인 여부에 따라 메뉴 출력 제어(계속)
	- 13-e. 사용자 인증 : 로그인 정보 활용

## 47일차(2021-09-01,수)

- 실전 프로젝트(eomcs-java-project)
	- 14-a. `Command` 디자인 패턴 : 적용 전 문제점 확인
	- 14-b. `Command` 디자인 패턴 : 메서드를 객체로 분리
	- 14-c. `Command` 디자인 패턴 : 리팩토링
	- 14-d. `Command` 디자인 패턴 : 기능 추가를 통해 커맨드 패턴의 유용성 확인 

## 48일차(2021-09-02,목)

- 실전 프로젝트(eomcs-java-project)
	- 14-e. `Command` 디자인 패턴 : 인터페이스로 객체의 사용 규칙 통일
	- 14-f. `Command` 디자인 패턴 : `Map`으로 커맨드 객체 관리

## 49일차(2021-09-03,금)

- 실전 프로젝트(eomcs-java-project)
	- 15. 비트 연산자 활용: 메뉴 권한 관리
- 팀 프로젝트 
	- 4차: 중간 구현 점검
		- 발표 순서
			- 반계령,배서연,하선영,김제이,김주창
				- 스터디위더스
			- 변민성,위정욱,박성준,구백연,이지호
				- 행복하share
			- 김은채,송다혜,조솔,우형민
				- 오늘의 공부
			- 김태호,조주리,신현지,김진현
				- APUJIMA
			- 윤수민,이용진,홍지현,문세철
				- 주류파인더
			- 최보균,이혜연,방우주,이서은,조대희
				- MySeoul

## 50일차(2021-09-06,월)

- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 51일차(2021-09-07,화)

- 실전 프로젝트(eomcs-java-project)
	- 16-a. 파일 입출력 다루기 : 바이너리 형식으로 데이터 입출력

## 52일차(2021-09-08,수)

- 자바 스트림 API(eomcs-java/com.eomcs.io)
	- ex01: File 클래스 사용법
	- ex02: FileInputStream/FileOutputStream 클래스 사용법
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 53일차(2021-09-09,목)

- 자바 스트림 API(eomcs-java/com.eomcs.io)
	- ex02: FileInputStream/FileOutputStream 클래스 사용법(계속)
	- ex03: FileReader/FileWriter 클래스 사용법
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 54일차(2021-09-10,금)

- 팀 프로젝트 
	- 팀별 프로젝트 구현
	- 5차: 중간 구현 점검
		- 발표 순서
			- 변민성,위정욱,박성준,구백연,이지호
				- 행복하share
			- 김은채,송다혜,조솔,우형민
				- 오늘의 공부
			- 김태호,조주리,신현지,김진현
				- APUJIMA
			- 윤수민,이용진,홍지현,문세철
				- 주류파인더
			- 최보균,이혜연,방우주,이서은,조대희
				- MySeoul
			- 반계령,배서연,하선영,김제이,김주창
				- 스터디위더스
- 디자인 패턴(eomcs-java/com.eomcs.design_pattern)
	- decorator: 데코레이터 패턴 소개
- 자바 스트림 API(eomcs-java/com.eomcs.io)
	- ex04: FileInputStream/FileOutputStream 을 이용하여 객체의 필드 값 출력하기
	- ex05: FileInputStream/FileOutputStream 을 상속 받아서 기능을 확장하기

## 55일차(2021-09-13,월)

- 자바 스트림 API(eomcs-java/com.eomcs.io)
	- ex06: 버퍼를 활용하는 이유
	- ex07: 상속으로 기능을 확장하는 방식의 한계점 이해하기
	- ex08: 포함관계로 기능을 확장하기
	- ex09: 데코레이터 설계 패턴을 적용하기
	- ex10: 자바에서 제공하는 스트림 클래스 사용하기
	- ex11: 객체를 serialize/deserialize 하기
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 56일차(2021-09-14,화)

- 자바 스트림 API(eomcs-java/com.eomcs.io)
	- ex11: 객체를 serialize/deserialize 하기(계속)
	- ex12: 연습
	- ex13: 스트림 API를 사용하여 바이트 배열이나 스트링 버퍼에 출력하기
	- ex14: 입출력 예외처리
- 실전 프로젝트(eomcs-java-project)
	- 16-a. 파일 입출력 다루기 : 바이너리 형식으로 데이터 입출력(계속)
		- BufferedInputStream/BufferedOutputStream 클래스 사용하기
		- 제네릭 문법 활용하기
	- 16-b. 파일 입출력 다루기 : 텍스트 형식으로 데이터 입출력
		- FileReader/FileWriter 클래스 사용하기
		- BufferedReader/PrintWriter 데코레이터 클래스 사용하기
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 57일차(2021-09-15,수)

- 실전 프로젝트(eomcs-java-project)
	- 16-b. 파일 입출력 다루기 : 텍스트 형식으로 데이터 입출력(계속)
		- BufferedReader/BufferedWriter 데코레이터 클래스 사용하기
		- 리팩토링 : 'Information Expert' GRASP 적용
		- 리팩토링 : '메서드 추출'
		- 리팩토링 : 제네릭 적용

## 58일차(2021-09-16,목)

- JSON Open API 사용법(eomcs-java/com.eomcs.openapi.json)
	- Gson 라이브러리를 사용하여 JSON 문자열을 다루는 방법
- 실전 프로젝트(eomcs-java-project)
	- 16-b. 파일 입출력 다루기 : 텍스트 형식으로 데이터 입출력(계속)
		- 리팩토링 : Task 도메인 클래스에 CsvValue 인터페이스 적용
		- JSON 형식으로 데이터를 입출력하기

## 59일차(2021-09-17,금)

- 실전 프로젝트(eomcs-java-project)
	- 17-a. 메뉴 리팩토링: 상세보기에서 변경, 삭제 기능 수행하기
	- 17-b. 메뉴 리팩토링: Command 인터페이스의 execute()에 파라미터 넘기기
	- 17-c. 메뉴 리팩토링: Command 객체 간에 종속성 제거하기
- 반 배치
	- A반
		- 김태호,조주리,신현지,김진현
		- 최보균,이혜연,방우주,이서은,조대희
		- 김은채,송다혜,조솔,우형민
	- B반
		- 반계령,하선영,김제이,김주창
		- 변민성,위정욱,박성준,구백연,이지호
		- 윤수민,이용진,홍지현,문세철
- 자리배치
	- A반(금요일)
		- [           칠    판         ]
		- [송다혜][XXXXXX][신현지][XXXXXX]
		- [XXXXXX][김태호][XXXXXX][우형민][XXXXXX]
		- [김진현][XXXXXX][이서은][XXXXXX][방우주]
		- [XXXXXX][조주리][XXXXXX][......][XXXXXX]
		- [최보균][XXXXXX][조대희][XXXXXX][이혜연]
		- [XXXXXX][조  솔][XXXXXX][김은채][XXX][에어콘]
	- B반(목요일)
		- [           칠    판         ]
		- [XXXXXX][......][XXXXXX][반계령]
		- [......][XXXXXX][변민성][XXXXXX][위정욱]
		- [XXXXXX][이용진][XXXXXX][하선영][XXXXXX]
		- [윤수민][XXXXXX][김주창][XXXXXX][문세철]
		- [XXXXXX][이지호][XXXXXX][김제이][XXXXXX]
		- [박성준][XXXXXX][홍지현][XXXXXX][구백연][에어콘]

## 60일차(2021-09-23,목)

- 실전 프로젝트(eomcs-java-project)
	- 18-a. `Observer` 디자인 패턴 : 옵저버 패턴이 필요한 이유
	- 18-b. `Observer` 디자인 패턴 : 옵저버 패턴으로 구조를 바꾸기
	- 18-c. `Observer` 디자인 패턴 : 옵저버로 파일 입출력 처리하기
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 61일차(2021-09-24,금)

- 실전 프로젝트(eomcs-java-project)
	- 19-a. 데이터 관리 서버 만들기 : 클라이언트/서버 프로젝트 준비
- 팀 프로젝트 
	- 팀별 프로젝트 구현
	- 6차: 중간 구현 점검
		- 발표 순서
			- 김은채,송다혜,조솔,우형민
				- 오늘의 공부
			- 김태호,조주리,신현지,김진현
				- APUJIMA
			- 윤수민,이용진,홍지현,문세철
				- 주류파인더
			- 최보균,이혜연,방우주,이서은,조대희
				- MySeoul
			- 반계령,배서연,하선영,김제이,김주창
				- 스터디위더스
			- 변민성,위정욱,박성준,구백연,이지호
				- 행복하share

## 62일차(2021-09-27,월)

- 실전 프로젝트(eomcs-java-project)
	- 19-b. 데이터 관리 서버 만들기 : 간단한 메시지 송수신
	- 19-c. 데이터 관리 서버 만들기 : 사용자가 입력한 명령처리
	- 19-d. 데이터 관리 서버 만들기 : 프로토콜 정의 및 적용
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 63일차(2021-09-28,화)

- 실전 프로젝트(eomcs-java-project)
	- 19-e. 데이터 관리 서버 만들기 : 통신 기능을 캡슐화
	- 19-f. 데이터 관리 서버 만들기 : 파일 및 데이터 처리 기능을 서버로 이전
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 64일차(2021-09-29,수)

- 실전 프로젝트(eomcs-java-project)
	- 19-f. 데이터 관리 서버 만들기 : 파일 및 데이터 처리 기능을 서버로 이전(계속)
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 65일차(2021-09-30,목)

- 실전 프로젝트(eomcs-java-project)
	- 19-f. 데이터 관리 서버 만들기 : 파일 및 데이터 처리 기능을 서버로 이전(계속)
	- 19-g. 데이터 관리 서버 만들기 : 다중 클라이언트의 접속 처리(Stateful)
	- 19-h. 데이터 관리 서버 만들기 : 다중 클라이언트의 접속 처리(Stateless)
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 66일차(2021-10-01,금)

- 실전 프로젝트(eomcs-java-project)
	- 20-a. 데이터 처리 코드를 캡슐화하기 : DAO 클래스 도입
- 팀 프로젝트 
	- 팀별 프로젝트 구현
- 팀 프로젝트 
	- 팀별 프로젝트 구현
	- 7차: 중간 구현 점검
		- 발표 순서
			- 김태호,조주리,신현지,김진현
				- APUJIMA
			- 윤수민,이용진,홍지현,문세철
				- 주류파인더
			- 최보균,이혜연,방우주,이서은,조대희
				- MySeoul
			- 반계령,배서연,하선영,김제이,김주창
				- 스터디위더스
			- 변민성,위정욱,박성준,구백연,이지호
				- 행복하share
			- 김은채,송다혜,조솔,우형민
				- 오늘의 공부

## 67일차(2021-10-05,화)

- DBMS(eomcs-docs)
	- DBMS 개요
	- MariaDB 설치 및 설정
	- SQL : DDL

- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 68일차(2021-10-06,수)

- DBMS(eomcs-docs)
	- SQL : DDL(계속)
	- SQL : DML
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 69일차(2021-10-07,목)

- DBMS(eomcs-docs)
	- SQL : DML(계속)
	- SQL : DQL
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 70일차(2021-10-08,금)

- DBMS(eomcs-docs)
	- SQL : DQL(계속)
	- JDBC 프로그래밍 개요
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 71일차(2021-10-12,화)

- DBMS(eomcs-java) : com.eomcs.jdbc
	- JDBC 프로그래밍: ex01 ~ ex02 
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 72일차(2021-10-13,수)

- DBMS(eomcs-java) : com.eomcs.jdbc
	- JDBC 프로그래밍: ex03 ~ ex04
		- Statement vs PreparedStatement
		- 자동 증가 PK 값 알아내기
		- 트랜잭션 다루기
- DB 모델링
	- ER-Diagram 도구 설치: exerd.com 에서 다운로드
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 73일차(2021-10-14,목)

- DB 모델링
	- DB 모델링 개요 및 실습
	- mini-pms DB 모델링 및 테이블 준비
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 74일차(2021-10-15,금)

- DB 모델링
	- 팀별 프로젝트의 DB 모델링 리뷰
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 75일차(2021-10-18,월)

- DB 모델링
	- 팀별 프로젝트의 DB 모델링 리뷰(계속)
- 실전 프로젝트(eomcs-java-project)
	- 21-a. 데이터 관리를 DBMS에게 맡기기 : JDBC API 사용
- 팀 프로젝트 
	- 팀별 프로젝트 구현

## 76일차(2021-10-19,화)

- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- JDBC 적용

## 77일차(2021-10-20,수)

- DBMS(eomcs-java) : com.eomcs.mybatis
	- Mybatis 퍼시스턴스 프레임어크 사용법: ex01 ~ ex03.c
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- Mybatis 퍼시스턴스 프레임워크 적용

## 78일차(2021-10-21,목)

- DBMS(eomcs-java) : com.eomcs.mybatis (계속)
	- Mybatis 퍼시스턴스 프레임어크 사용법: ex03.c ~ 
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- Mybatis 퍼시스턴스 프레임워크 적용

## 79일차(2021-10-22,금)

- DBMS(eomcs-java) : com.eomcs.mybatis (계속)
	- Mybatis 퍼시스턴스 프레임어크 사용법: ex03.c ~ 
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- Mybatis 퍼시스턴스 프레임워크 적용(계속): DAO 구현체를 자동으로 생성하는 방법

## 80일차(2021-10-25,월)

- 서블릿 프로그래밍(eomcs-java) : eomcs-servlet
	- 서블릿 프로그래밍 개요 및 실습
- 실전 프로젝트(eomcs-java-project)
	- 23-a. 웹 애플리케이션 서버 아키텍처로 전환하기 : Servlet 기술 도입
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- Mybatis 퍼시스턴스 프레임워크 적용(계속): DAO 구현체를 자동으로 생성하는 방법


## 81일차(2021-10-26,화)

- 서블릿 프로그래밍(eomcs-java) : eomcs-servlet
	- 서블릿 프로그래밍 개요 및 실습
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- 서블릿 기술 적용
- 실전 프로젝트(eomcs-java-project)
	- 23-a. 웹 애플리케이션 서버 아키텍처로 전환하기 : Servlet/JSP 기술 도입

## 82일차(2021-10-27,수)

- 서블릿 프로그래밍(eomcs-java) : eomcs-servlet
	- HTML 사용법
- 실전 프로젝트(eomcs-java-project)
	- 23-a. 웹 애플리케이션 서버 아키텍처로 전환하기 : Servlet/JSP 기술 도입(계속)
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- 서블릿 기술 적용(계속)

## 83일차(2021-10-28,목)

- 서블릿 프로그래밍(eomcs-java) : eomcs-servlet
	- JSP 프로그래밍
- 실전 프로젝트(eomcs-java-project)
	- 23-a. 웹 애플리케이션 서버 아키텍처로 전환하기 : Servlet/JSP 기술 도입(계속)
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- 서블릿 기술 적용(계속)

## 84일차(2021-10-29,금)

- 서블릿 프로그래밍(eomcs-java) : eomcs-servlet
	- JSP 프로그래밍
- 실전 프로젝트(eomcs-java-project)
	- 23-b. 웹 애플리케이션 서버 아키텍처로 전환하기 : MVC 패턴 적용
	- 23-c. 웹 애플리케이션 서버 아키텍처로 전환하기 : EL, JSTL 적용
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- MVC + EL + JSTL 기술 적용


## 85일차(2021-11-01,월)

- CSS(eomcs-java) : eomcs-servlet
	- CSS 사용법
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- MVC + EL + JSTL 기술 적용		

## 86일차(2021-11-02,화)

- 자소서 작성법

## 87일차(2021-11-03,수)

- CSS(eomcs-java) : eomcs-servlet
	- CSS 사용법(계속)
	- Bootstrap CSS 라이브러리 적용
- 실전 프로젝트(eomcs-java-project)
	- 23-d. 웹 애플리케이션 서버 아키텍처로 전환하기 : Bootstrap 적용
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- Bootstrap 기술 적용	

## 88일차(2021-11-04,목)

- javascript(eomcs-java) : eomcs-servlet
	- JavaScript 프로그래밍
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- Bootstrap 기술 적용

## 89일차(2021-11-05,금)

- javascript(eomcs-java) : eomcs-servlet
	- JavaScript 프로그래밍(계속)
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- 자바스크립트 기술 적용

## 90일차(2021-11-08,월)

- javascript(eomcs-java) : eomcs-servlet
	- JavaScript 프로그래밍(계속)
- 실전 프로젝트(eomcs-java-project)
	- 23-e. 웹 애플리케이션 서버 아키텍처로 전환하기 : JavaScript 적용 + POST + 필터 적용
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- 자바스크립트 기술 적용

## 91일차(2021-11-09,화)

- 서블릿 프로그래밍(eomcs-java) : eomcs-servlet
- 실전 프로젝트(eomcs-java-project)
	- 23-e. 웹 애플리케이션 서버 아키텍처로 전환하기 : JavaScript 적용 + POST + 필터 적용(계속)	
	- 23-f. 웹 애플리케이션 서버 아키텍처로 전환하기 : 템플릿 적용
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- 자바스크립트 기술 적용

## 92일차(2021-11-10,수)
- 서블릿 프로그래밍(eomcs-java) : eomcs-servlet
- 실전 프로젝트(eomcs-java-project)
	- 23-g. 웹 애플리케이션 서버 아키텍처로 전환하기 : get/post, 파일 업로드, 썸네일, 로그인/로그아웃 적용
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- 자바스크립트 기술 적용

## 93일차(2021-11-11,목)
- 서블릿 프로그래밍(eomcs-java) : eomcs-servlet
- 실전 프로젝트(eomcs-java-project)
	- 23-g. 웹 애플리케이션 서버 아키텍처로 전환하기 : get/post, 파일 업로드, 썸네일, 로그인/로그아웃, 쿠키 적용(계속)
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- 자바스크립트 기술 적용

## 94일차(2021-11-12,금)
- 서블릿 프로그래밍(eomcs-java) : eomcs-servlet
- 실전 프로젝트(eomcs-java-project)
	- 24-a. Spring WebMVC 프레임워크 도입하기 : 프레임워크 적용
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- 스프링 프레임워크 적용

## 95일차(2021-11-15,월)
- 스프링 프레임워크(eomcs-java-project) :
	- 프론트 컨트롤러 만들기
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- 스프링 프레임워크 적용

## 96일차(2021-11-16,화)
- 스프링 프레임워크(eomcs-java) : eomcs-spring-webmvc
	- 스프링 IoC 컨테이너 사용법
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- 스프링 프레임워크 적용

## 97일차(2021-11-17,수)
- 스프링 프레임워크(eomcs-java) : eomcs-spring-webmvc
	- 스프링 IoC 컨테이너 사용법(계속)
- 이수자평가
- 팀 프로젝트 
	- 팀별 프로젝트 구현
		- 스프링 프레임워크 적용

## 98일차(2021-11-18,목)
- 스프링 프레임워크(eomcs-java) : eomcs-spring-webmvc
	- 스프링 WebMVC 프레임워크 사용법
- 팀 프로젝트  
	- 팀별 프로젝트 구현
		- 스프링 프레임워크 적용

## 99일차(2021-11-19,금)
- 스프링 프레임워크(eomcs-java) : eomcs-spring-webmvc
	- 스프링 WebMVC 프레임워크 사용법
- 팀 프로젝트  
	- 팀별 프로젝트 구현
		- 스프링 프레임워크 적용

## 100일차(2021-11-22,월)
- 스프링 프레임워크(eomcs-java) : eomcs-spring-webmvc
	- 스프링 WebMVC 프레임워크 사용법
- 팀 프로젝트  
	- 팀별 프로젝트 구현
		- 스프링 프레임워크 적용

# google meet
https://meet.google.com/shs-ivqm-rvr



# uk2_study_ 개념과 궁금한 것들!

## 톰캣과 아파치
 - Tomcat : tomcat 다운시 여러폴더들과 파일이 들어있는 하나의 폴더가 생성됨
            스프링 코딩 -> war 파일 빌드하면 .class/jsp/img/css/js 으로 압축된다
            특정 폴더에 war파일 넣고 실행하면 스프링서비스가 톰캣을 사용해서 돌게 됨!

- 아파치 : 클라이언트의 요청을 정적으로 처리하는 웹

## web서버 와 was서버
 * 서버 => 컴퓨터
 html,css,java,DB등의 정보를 디렉토리에 저장 -> 서버에 저장-> 주소접속하면 소스 볼 수 있음
 - web : 정적인 자료를 처리 / 그 안의 파일들이 바뀌지 않는 화면 ex) 편의점에 진열된 물건
        클라이언트 요청시, 서버에 저장된 정적인 파일들을 모두 보냄 -> 리소스 많이 차지한다
        -> 이 점을 보완하기 위해 동적 웹으로 파일을 처리
        ex) 아파치, Nginx 등
 - was(web application server) : 동적인 자료를 처리 / 항상 같은 글이 뜨지 않는 사이트, 게시판 웹 ex) 주문에 맞춰서 요리해주는 식당 음식
         ex) 톰캣 등

 * 클라이언트 요청 -> 웹서버에서 정적date처리 --전달--> 웹컨테이너(jsp,servlet구동환경제공)에서 동적date처리
   결과값 받아 클라이언트 전송 <--전달---  동적인 데이터 가공해 정적인 데이터 만들어줌(웹컨테이너가)  

 * 사용자 요청을 http웹서버로 받고 내부 프로그램은 was로 처리할까? 굳이? 왜?
   1) 손님들에게 서버의 정보를 감추기 위해서, 파일이 어느 폴더에 있는지, 서비스가 몇번 포트로 돌고 있는지 감춤 => 리버스 프록시
    ex) 요리를 만드는 곳이 아닌, 정적 리소스들의 방위치가 아닌 응접실에서 손님들에게 음식을 제공   
   2) 톰캣이 여러개 돌고 있을 때 발런스 맞춰줌, 다른 war들도 마찬가지 => 로드밸런싱
    ex) 손님이 너무 몰려있을 때 손님들을 분산해서 배치해줌

 * 서버 한대 -> 하나의 사이트 돌릴 때 여러개 톰캣을 두는 이유?
   1) 새기능 추가, 동적부분 업데이트 필요 시 끊김없이 서비스를 사용자에게 제공해주기 위해서 => 지속성
   2) 성능측면
   3) 한번 꺼내온 것을 가까운 곳에 모아두고 다음에 꺼낼때 빠르게 꺼내오기 위해 => 캐싱

## forward proxy 와 reverse proxy
 - forward proxy : 클라이언트 요청 ---> forward proxy ----> 인터넷 ---> 내부서버
   : 클라이언트가 인터넷에 직접 연결하는게 아니라 프록시서버가 요청을 받아 결과를 클라이언트에게 전달
    프록시 서버는 캐시를 이용해 자주 사용하는 데이터를 요청하지 않고 캐시에서 가지고 올 수 있으므로 성능향상에 좋음
 - reverse proxy : 클라이언트 요청 ---> 인터넷 ----> reverse poroxy ----> 내부서버
   : 클라이언트가 인터넷에 데이터 요청하면 리버스프록시가 이 요청을 받아 내부 서버에서 데이터를 받은 후
   클라이언트에게 전달
   내부서버(was)에 직접적으로 접근하면 DB접근 가능 -> 중간에 리버스 프록시두고 통신
   내부 서버에 대한 설정으로 로드밸런싱이나 서버 확장 등에 유리

## 트랜잭션
 - 하나의 작업을 수행하기 위해서 모든 데이터베이스 연산을 모아둔 것
   데이터베이스 변환시기는 하나의 논리적기능을 수행하기 위한 작업단위
   장애 발생 시 모든 작업을 원상태로 돌린다!
 - 트랜잭션 연산이 모두 완료되어야만, 실제 데이터베이스에 반영된다.
 - commit : 모두 완료되면 한번에 DB에 반영
 - rollback :  트랜잭션 수행 실패선언 -> rollback연산실행 -> 트랜잭션 수행 전으로 되돌아감
 - savepoint : 모든 연산 취소하지 않고 특정부분으로 되돌리고 싶을때 사용

## MVC패턴
 - 프로젝트를 구성할 때 구성요소를 세가지로 구분
   사용자가 보는 페이지, 데이터처리, 이 2가지를 연결하는 컨트롤러
   각각 맡은 역활에 집중할 수 있고 유지보수가 쉽다.
 - 모델 : 데이터 관련된 것 들, DB 형식, 저장, 수정 등의 코드들 여기서 이뤄짐
 - 뷰 : 눈에 보이는 html,css코드들이 있음
        이 소스들을 사용자들이 시작적으로 볼 수 있게 해주는 코드들 작성
 - 컨트롤러 : model DB와 view연결
              사용자가 구현된 DB를 읽고 쓰고 지울 수 있게 제어하는 부분

## 프레임워크 와 라이브러리
 - 프레임워크 : 개별적인 것들이 연결되어서 기초골격이 갖춰진 것
                프레임워크를 기본틀로 삼아 그위에 덧붙이면된다.
 - 라이브러리 : 개별적인 기능들을 남이 짜놓은 코드

## MVC model1 VS model2
 - model1 : 클라이언트가 요청하면 jsp가 받아 비즈니스로직, 화면구현 모든 요청을 처리
            빠르고 쉽게 개발할 수 있지만 jsp파일이 거대해진다. 유지보수에 어렵다.
 - model2 : 클라이언트가 요청하면 servelt에서 비즈니스로직 구현
            jsp에서 화면구현을 합니다. view와 컨트롤러가 분리되어있습니다.
            구조가 쉽고 유지보수가 쉽습니다. 설계는 어렵습니다.

## JSP와 Servlet
 - jsp : html에 자바코드를 추가해 동적웹페이지를 만들어줌
         view 페이지 나타날 때 많이 사용
 - servelet : 자바 코드 안에 html 코드 들어감 controller많이 사용
 - jsp와 servlet의 차이점
    : 기능적인 차이는 없고 역활차이만 있음
      servlet은 controller에서 많이 사용되고 jsp는 view페이지에 많이 사용
      servlet이 불편해서 jsp가 나오게 되었다.

## Ajax란
 - 자바스크립트를 이용해 서버에 데이터를 비동기방식으로 요청하는 것
   전체페이지중에서 특정영역의 데이터를 바꾸고 싶을때, 데이터 일부분만 불러오는 기법

## 비동기방식
 - 작업을 할 때 멈추지않고 요청한 업무를 진행하는 방식
   요청과 결과가 동시에 일어나지 않는 방식, 결과까지 시간이 걸리지만
   그 시간동안 다른 작업을 할 수 있다.

## Ajax 돌아가는 원리
 - 사용자에 의해 이벤트가 발생하면 자바스크립트가 작동하고
   자바스크립트에서 XMLHTTPRequest객체를 이용해 서버로 요청을 보낸다.

## 제이쿼리란?
 - 자바스크립트문법을 간소화해서 나온 문법

## 자바스크립트란?
 - 웹 서버로 통신되는게 아니라 웹 브라우저에서 바로 수행되는 언어
 - 브라우저를 프로그래밍적으로 제어한다. 

## get방식과 post방식 put방식
 - get방식 : 클라이언트가 서버로 보내는 요청
             정보를 가져와 조회할때 사용, URL에 데이터 노출됨
 - post방식 : 데이터를 서버로 제출할때 사용 
              body에 정보 담아 전송, URL에 데이터 노출 안돼서 캐싱 불가능
 - put방식 : 정보를 변경할 때 사용

## node.js란?
 - 탈웹브라우저 : 자바스크립트를 웹 브라우저에서뿐만 아니라 서버에서도 사용할 수 있도록 만든 프로그램
   원래 자바스크립트를 웹에서만 사용 했는데 서버에서도 사용할 수 있게 만들어준 프로그램으로
   node.js가 나오면서 자바스크립트 한가지 언어로 전체 웹페이지를 만들수 있게 되었다.
   이벤트기반 비동기 방식

## REST API란?
 - REST 기반으로 만들어진 API

## REST?
 - http url을 통해 리소스 명시하고 http method(get,post,put,delete)를 통해
   해당 리소스에 대한 crud를 적용하는 것

## 디비 쿼리 순서도
 - from- where- select -order by
 from : 전체 테이블의 결과 가지고 옴
 where : form절에서 읽어온 테이블에서
            조건에 맞는 결과만 가지고 옴
 select : 그 중에서 어떤 열을 출력해줄지 선택
 order by : 행을 정렬해주는 쿼리

## 서브쿼리란?
 - 쿼리안에 들어있는 또다른 쿼리

## inner join
 - 보통 join이라고 통칭
   두 테이블을 결합하여 나타날때 사용

## 오버로딩 
 - 기존에 없는 새로운 메소드를 추가하는 것.
   같은 클래스내에 적용합니다. 메소드명만 동일하면 된다.

## 오버라이딩
 - 부모 클래스로부터 상속받은 메소드를 자식클래스에서 재정의하는 것
   메소드명, 변수, 리턴 값이 모두 같아야 한다.

## 자바란?
 - 프로그래밍 언어로 객체지향언어이고 
   JVM이 있기때문에 운영체제에 따라 수정을 하지 않아도 된다. 보안이 좋다.

## JVM 
 - 자바 프로그램을 실행시키는 가상 운영체제
 - 자바 파일을 컴파일 하면 자바 클래스 파일은 바이트 코드를 사용하는데
   바이트 코드를 컴퓨터에서 바로 사용할 수 없어서 jvm을 사용

## JDK
 - 컴파일 프로그램으로 바이트 코드 생성

## 객체지향이란?
 - 객체들간의 상호작용을 통해 설계하고 개발하는 것
   서로 연관되어있는데 데이터, 처리 등을 하나의 그릇안에 모아서 그룹해놓은 프로그램 기법

## 객체지향 특징
 - 상위 클래스의 모든걸 하위클래스가 이어 받는다.
   데이터와 코드를 외부가 알 수 없고
   데이터의 구조와 기능을 하나의 캡슐형태로 만든다.
   한 객체가 여러형태로 재구성 될 수 있다.
   객체의 공통적인 기능과 속성을 추출해 정의할 수 있다.

## 객체지향 장점
 - 코드 재사용 높음, 개발 빠르게 할 수 있음, 유지보수 용이

## 객체지향 단점 
 - 설계시간 오래 걸림, 속도 느림